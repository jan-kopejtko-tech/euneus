<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knight Swarm - Emoji Edition</title>
    <script src="game-config.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <script src="https://unpkg.com/colyseus.js@0.15.10/dist/colyseus.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
        }
        #game-container {
            box-shadow: 0 0 40px rgba(200, 150, 50, 0.4);
        }
        #connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            z-index: 1000;
        }
        .connected { color: #00ff00; }
        .disconnected { color: #ff0000; }
        .connecting { color: #ffaa00; }
    </style>
</head>
<body>
    <div id="connection-status">
        <span class="connecting"></span>
    </div>
    
    <!-- Hero Class Selection Screen -->
    <div id="class-selection" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 5000; display: flex; align-items: center; justify-content: center; font-family: Arial, sans-serif;">
        <div style="text-align: center; color: white;">
            <h1 id="choose-hero-title" style="font-size: 48px; margin-bottom: 40px; color: #ffd700;"></h1>
            <div style="display: flex; gap: 40px; justify-content: center;">
                <!-- Tank -->
                <div class="hero-card" data-class="tank" style="width: 250px; padding: 30px; background: #2a2a2a; border: 3px solid #555; border-radius: 15px; cursor: pointer; transition: all 0.3s;">
                    <div class="hero-icon-display" style="font-size: 80px; margin-bottom: 15px;"></div>
                    <h2 class="hero-name" style="color: #4dabf7; font-size: 32px; margin: 10px 0;"></h2>
                    <div style="color: #aaa; font-size: 16px; margin: 15px 0;">
                        <div class="stat-hp"></div>
                        <div class="stat-damage"></div>
                        <div class="stat-speed"></div>
                        <div class="stat-range"></div>
                    </div>
                    <div class="hero-description" style="margin-top: 15px; color: #ffd700; font-size: 14px;"></div>
                </div>
                
                <!-- Assassin -->
                <div class="hero-card" data-class="assassin" style="width: 250px; padding: 30px; background: #2a2a2a; border: 3px solid #555; border-radius: 15px; cursor: pointer; transition: all 0.3s;">
                    <div class="hero-icon-display" style="font-size: 80px; margin-bottom: 15px;"></div>
                    <h2 class="hero-name" style="color: #ff6b6b; font-size: 32px; margin: 10px 0;"></h2>
                    <div style="color: #aaa; font-size: 16px; margin: 15px 0;">
                        <div class="stat-hp"></div>
                        <div class="stat-damage"></div>
                        <div class="stat-speed"></div>
                        <div class="stat-range"></div>
                    </div>
                    <div class="hero-description" style="margin-top: 15px; color: #ffd700; font-size: 14px;"></div>
                </div>
                
                <!-- Mage -->
                <div class="hero-card" data-class="mage" style="width: 250px; padding: 30px; background: #2a2a2a; border: 3px solid #555; border-radius: 15px; cursor: pointer; transition: all 0.3s;">
                    <div class="hero-icon-display" style="font-size: 80px; margin-bottom: 15px;"></div>
                    <h2 class="hero-name" style="color: #a78bfa; font-size: 32px; margin: 10px 0;"></h2>
                    <div style="color: #aaa; font-size: 16px; margin: 15px 0;">
                        <div class="stat-hp"></div>
                        <div class="stat-damage"></div>
                        <div class="stat-speed"></div>
                        <div class="stat-range"></div>
                    </div>
                    <div class="hero-description" style="margin-top: 15px; color: #ffd700; font-size: 14px;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Hero Stats HUD -->
    <div id="hero-hud" style="position: fixed; top: 20px; left: 20px; z-index: 4000; font-family: Arial, sans-serif; pointer-events: none; display: none;">
        <div style="background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; border: 2px solid #ffd700; min-width: 250px;">
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                <div id="hero-icon" style="font-size: 48px;"></div>
                <div>
                    <div id="hero-class" style="color: #ffd700; font-size: 24px; font-weight: bold;"></div>
                    <div id="hero-level" style="color: #00ff00; font-size: 18px;"></div>
                </div>
            </div>
            
            <!-- HP Bar -->
            <div style="margin: 8px 0;">
                <div style="display: flex; justify-content: space-between; font-size: 14px; color: white; margin-bottom: 3px;">
                    <span id="hp-label"></span>
                    <span id="hp-text">100/100</span>
                </div>
                <div style="width: 100%; height: 20px; background: #333; border-radius: 10px; overflow: hidden;">
                    <div id="hp-bar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #ff0000, #ff6b6b); transition: width 0.3s;"></div>
                </div>
            </div>
            
            <!-- XP Bar -->
            <div style="margin: 8px 0;">
                <div style="display: flex; justify-content: space-between; font-size: 14px; color: white; margin-bottom: 3px;">
                    <span id="xp-label"></span>
                    <span id="xp-text">0/100</span>
                </div>
                <div style="width: 100%; height: 15px; background: #333; border-radius: 10px; overflow: hidden;">
                    <div id="xp-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ffd700, #ffaa00); transition: width 0.3s;"></div>
                </div>
            </div>
            
            <!-- Stats -->
            <div style="margin-top: 10px; font-size: 14px; color: #aaa;">
                <div style="display: flex; justify-content: space-between; margin: 3px 0;">
                    <span id="damage-label"></span>
                    <span id="stat-damage" style="color: white;">20</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin: 3px 0;">
                    <span id="speed-label"></span>
                    <span id="stat-speed" style="color: white;">220</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin: 3px 0;">
                    <span id="range-label"></span>
                    <span id="stat-range" style="color: white;">80</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin: 3px 0;">
                    <span id="army-label"></span>
                    <span id="stat-army" style="color: white;">1</span>
                </div>
            </div>
        </div>
        
        <!-- Abilities -->
        <div id="abilities-bar" style="margin-top: 15px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 10px; border: 2px solid #ffd700;">
            <div style="display: flex; gap: 10px;">
                <div class="ability" data-key="Q" style="width: 60px; height: 60px; background: #2a2a2a; border: 2px solid #666; border-radius: 8px; position: relative; cursor: pointer;">
                    <div class="ability-icon-dash" style="font-size: 32px; text-align: center; line-height: 56px;"></div>
                    <div style="position: absolute; bottom: 2px; right: 4px; font-size: 12px; color: white; font-weight: bold;">Q</div>
                    <div class="ability-cooldown" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); border-radius: 6px; display: none; align-items: center; justify-content: center; color: white; font-size: 20px; font-weight: bold;"></div>
                </div>
                <div class="ability" data-key="E" style="width: 60px; height: 60px; background: #2a2a2a; border: 2px solid #666; border-radius: 8px; position: relative; cursor: pointer;">
                    <div class="ability-icon-aoe" style="font-size: 32px; text-align: center; line-height: 56px;"></div>
                    <div style="position: absolute; bottom: 2px; right: 4px; font-size: 12px; color: white; font-weight: bold;">E</div>
                    <div class="ability-cooldown" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); border-radius: 6px; display: none; align-items: center; justify-content: center; color: white; font-size: 20px; font-weight: bold;"></div>
                </div>
            </div>
            <div id="abilities-description" style="color: #aaa; font-size: 11px; margin-top: 5px; text-align: center;">
            </div>
        </div>
    </div>
    
    <div id="game-container"></div>
    
    <script>
        // Initialize UI with text from config
        document.addEventListener('DOMContentLoaded', () => {
            // Connection status
            document.querySelector('#connection-status .connecting').textContent = GameConfig.text.connecting;
            
            // Class selection title
            document.getElementById('choose-hero-title').textContent = GameConfig.text.chooseHero;
            
            // Populate hero cards
            const heroCards = document.querySelectorAll('.hero-card');
            heroCards.forEach(card => {
                const classType = card.dataset.class;
                const classData = GameConfig.classes[classType];
                
                // Icon
                card.querySelector('.hero-icon-display').textContent = classData.icon;
                
                // Name
                const nameMap = {
                    tank: GameConfig.text.tankName,
                    assassin: GameConfig.text.assassinName,
                    mage: GameConfig.text.mageName
                };
                card.querySelector('.hero-name').textContent = nameMap[classType];
                
                // Stats
                const speedRating = classType === 'tank' ? GameConfig.text.speedSlow : 
                                   classType === 'assassin' ? GameConfig.text.speedFast : 
                                   GameConfig.text.speedNormal;
                
                const rangeRating = classType === 'mage' ? GameConfig.text.rangeLong : GameConfig.text.rangeShort;
                
                const hpColor = classType === 'tank' ? '#00ff00' : classType === 'assassin' ? '#ff6b6b' : '#ffaa00';
                const damageColor = classType === 'assassin' ? '#00ff00' : '#ffaa00';
                const speedColor = classType === 'assassin' ? '#00ff00' : classType === 'tank' ? '#ff6b6b' : '#ffaa00';
                const rangeColor = classType === 'mage' ? '#00ff00' : '#ffaa00';
                
                card.querySelector('.stat-hp').innerHTML = `${GameConfig.text.hpLabel.split(' ')[0]} HP: <span style="color: ${hpColor};">${classData.maxHp}</span>`;
                card.querySelector('.stat-damage').innerHTML = `${GameConfig.text.damageLabel.split(' ')[0]} Damage: <span style="color: ${damageColor};">${classData.damage}</span>`;
                card.querySelector('.stat-speed').innerHTML = `${GameConfig.text.speedLabel.split(' ')[0]} Speed: <span style="color: ${speedColor};">${speedRating}</span>`;
                card.querySelector('.stat-range').innerHTML = `${GameConfig.text.rangeLabel.split(' ')[0]} Range: <span style="color: ${rangeColor};">${rangeRating}</span>`;
                
                // Description
                const descMap = {
                    tank: GameConfig.text.tankDescription,
                    assassin: GameConfig.text.assassinDescription,
                    mage: GameConfig.text.mageDescription
                };
                card.querySelector('.hero-description').textContent = descMap[classType];
            });
            
            // HUD labels
            document.getElementById('hp-label').textContent = GameConfig.text.hpLabel;
            document.getElementById('xp-label').textContent = GameConfig.text.xpLabel;
            document.getElementById('damage-label').textContent = GameConfig.text.damageLabel;
            document.getElementById('speed-label').textContent = GameConfig.text.speedLabel;
            document.getElementById('range-label').textContent = GameConfig.text.rangeLabel;
            document.getElementById('army-label').textContent = GameConfig.text.armyLabel;
            
            // Abilities
            document.querySelector('.ability-icon-dash').textContent = GameConfig.abilities.dash.emoji;
            document.querySelector('.ability-icon-aoe').textContent = GameConfig.abilities.aoe.emoji;
            document.getElementById('abilities-description').textContent = GameConfig.text.abilityDash + ' | ' + GameConfig.text.abilityAOE;
        });

        const config = {
            type: Phaser.CANVAS,
            width: 1200,
            height: 800,
            parent: 'game-container',
            backgroundColor: '#2d5016',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const WORLD_WIDTH = GameConfig.world.width;
        const WORLD_HEIGHT = GameConfig.world.height;

        let player;
        let allies;
        let mobs;
        let pointer;
        
        let enemyPlayer;
        let enemyAllies;
        
        let kills = 0;
        let nextAllyAt = 3;
        
        let killText;
        let armyText;
        let playerCountText;
        
        let powerups = null;
        let bosses = null;
        
        let lastInputSent = 0;
        const INPUT_SEND_INTERVAL = 100;
        
        let deathOverlay;
        let deathText;
        let retryButton;
        let isPlayerDead = false;

const SERVER_URL = "wss://euneus-production.up.railway.app";

let client = new Colyseus.Client(SERVER_URL);
let room;
let myPlayerId;
let otherPlayers = {};
let otherPlayerAllies = {};
let serverMobs = {};
let gameScene;
let game;

let selectedClass = null;
let heroStats = {
    level: 1,
    xp: 0,
    xpToNext: 100,
    maxHp: 100,
    hp: 100,
    damage: 20,
    speed: 220,
    range: 80
};

const CLASS_CONFIGS = GameConfig.classes;

let abilities = {
    dash: { cooldown: GameConfig.abilities.dash.cooldown, lastUsed: 0, key: GameConfig.abilities.dash.key },
    aoe: { cooldown: GameConfig.abilities.aoe.cooldown, lastUsed: 0, key: GameConfig.abilities.aoe.key }
};

document.addEventListener('DOMContentLoaded', () => {
    const heroCards = document.querySelectorAll('.hero-card');
    
    heroCards.forEach(card => {
        card.addEventListener('mouseenter', () => {
            card.style.transform = 'scale(1.05)';
            card.style.borderColor = '#ffd700';
        });
        
        card.addEventListener('mouseleave', () => {
            card.style.transform = 'scale(1)';
            card.style.borderColor = '#555';
        });
        
        card.addEventListener('click', () => {
            selectedClass = card.dataset.class;
            const config = CLASS_CONFIGS[selectedClass];
            
            heroStats.maxHp = config.maxHp;
            heroStats.hp = config.maxHp;
            heroStats.damage = config.damage;
            heroStats.speed = config.speed;
            heroStats.range = config.range;
            
            document.getElementById('class-selection').style.display = 'none';
            document.getElementById('hero-hud').style.display = 'block';
            
            document.getElementById('hero-icon').textContent = config.icon;
            document.getElementById('hero-class').textContent = selectedClass.toUpperCase();
            updateHeroHUD();
            
            startGame();
        });
    });
});

function updateHeroHUD() {
    document.getElementById('hero-level').textContent = `${GameConfig.text.level} ${heroStats.level}`;
    document.getElementById('hp-text').textContent = `${Math.round(heroStats.hp)}/${heroStats.maxHp}`;
    document.getElementById('hp-bar').style.width = `${(heroStats.hp / heroStats.maxHp) * 100}%`;
    document.getElementById('xp-text').textContent = `${heroStats.xp}/${heroStats.xpToNext}`;
    document.getElementById('xp-bar').style.width = `${(heroStats.xp / heroStats.xpToNext) * 100}%`;
    document.getElementById('stat-damage').textContent = heroStats.damage;
    document.getElementById('stat-speed').textContent = heroStats.speed;
    document.getElementById('stat-range').textContent = heroStats.range;
    document.getElementById('stat-army').textContent = allies ? allies.children.entries.length + 1 : 1;
}

function gainXP(amount) {
    heroStats.xp += amount;
    
    while (heroStats.xp >= heroStats.xpToNext) {
        heroStats.xp -= heroStats.xpToNext;
        heroStats.level++;
        heroStats.xpToNext = Math.floor(heroStats.xpToNext * 1.5);
        
        heroStats.maxHp += 10;
        heroStats.hp = heroStats.maxHp;
        heroStats.damage += 2;
        heroStats.range += 2;
        
        if (player && player.active) {
            const levelUpText = gameScene.add.text(player.x, player.y - 50, GameConfig.text.levelUp, {
                fontSize: '32px',
                color: '#ffd700',
                fontStyle: 'bold',
                stroke: '#000000',
                strokeThickness: 6
            }).setOrigin(0.5);
            
            gameScene.tweens.add({
                targets: levelUpText,
                y: player.y - 100,
                alpha: 0,
                duration: 2000,
                onComplete: () => levelUpText.destroy()
            });
        }
    }
    
    updateHeroHUD();
}

function startGame() {
    console.log('üéÆ Starting game...');
    
    document.getElementById('game-container').style.display = 'block';
    
    game = new Phaser.Game(config);
    console.log('‚úÖ Phaser game created');
}

async function connectToMultiplayer() {
    try {
        console.log("üîÑ Connecting to server:", SERVER_URL);
        
        room = await client.joinOrCreate("battle");
        myPlayerId = room.sessionId;
        
        console.log("‚úÖ Connected! Room ID:", room.id);
        console.log("‚úÖ My Player ID:", myPlayerId);
        
        updateConnectionStatus('connected', `${GameConfig.text.connected} | Room: ${room.id.slice(0,8)}`);
        
        room.onMessage("init", (message) => {
            console.log("üì¶ Received init message:", message);
            myPlayerId = message.playerId;
        });
        
        room.onStateChange((state) => {
            if (!gameScene) return;
            
            const playerCount = Object.keys(state.players).length;
            if (playerCountText) {
                playerCountText.setText(`${GameConfig.text.players}: ${playerCount}`);
            }
            
            state.players.forEach((serverPlayer, sessionId) => {
                if (sessionId === myPlayerId) return;
                
                if (!otherPlayers[sessionId]) {
                    console.log("‚ûï Creating other player:", sessionId);
                    const sprite = gameScene.physics.add.sprite(
                        serverPlayer.x,
                        serverPlayer.y,
                        'player'
                    );
                    sprite.setTint(0xff4444);
                    sprite.setData('hp', serverPlayer.hp);
                    sprite.setData('maxHp', serverPlayer.maxHp);
                    sprite.setData('team', 'red');
                    sprite.setData('isOtherPlayer', true);
                    sprite.setData('damage', 20);
                    sprite.setData('attackRange', 80);
                    sprite.setData('attackSpeed', 500);
                    sprite.setData('lastAttack', 0);
                    otherPlayers[sessionId] = sprite;
                } else {
                    const sprite = otherPlayers[sessionId];
                    if (sprite && sprite.active) {
                        const lerpFactor = 0.6;
                        const newX = Phaser.Math.Linear(sprite.x, serverPlayer.x, lerpFactor);
                        const newY = Phaser.Math.Linear(sprite.y, serverPlayer.y, lerpFactor);
                        
                        sprite.setPosition(newX, newY);
                        sprite.setRotation(serverPlayer.angle + Math.PI / 2);
                        sprite.setData('hp', serverPlayer.hp);
                    }
                }
                
                if (serverPlayer.allyData && serverPlayer.allyData.length > 0) {
                    if (!otherPlayerAllies[sessionId]) {
                        otherPlayerAllies[sessionId] = [];
                    }
                    
                    const allySprites = otherPlayerAllies[sessionId];
                    const allyCount = Math.floor(serverPlayer.allyData.length / 4);
                    
                    for (let i = 0; i < allyCount; i++) {
                        const x = serverPlayer.allyData[i * 4];
                        const y = serverPlayer.allyData[i * 4 + 1];
                        const angle = serverPlayer.allyData[i * 4 + 2];
                        const isArcher = serverPlayer.allyData[i * 4 + 3] === 1;
                        
                        if (!allySprites[i]) {
                            const texture = isArcher ? 'archer' : 'knight';
                            const allySprite = gameScene.physics.add.sprite(x, y, texture);
                            allySprite.setTint(0xff4444);
                            allySprite.setData('team', 'red');
                            allySprite.setData('isArcher', isArcher);
                            allySprite.setData('hp', isArcher ? 5 : 10);
                            allySprite.setData('maxHp', isArcher ? 5 : 10);
                            allySprite.setData('damage', isArcher ? 2.5 : 5);
                            allySprite.setData('attackRange', isArcher ? 160 : 75);
                            allySprite.setData('attackSpeed', isArcher ? 850 : 550);
                            allySprite.setData('lastAttack', 0);
                            allySprites[i] = allySprite;
                        } else {
                            const allySprite = allySprites[i];
                            if (allySprite && allySprite.active) {
                                const newX = Phaser.Math.Linear(allySprite.x, x, 0.6);
                                const newY = Phaser.Math.Linear(allySprite.y, y, 0.6);
                                allySprite.setPosition(newX, newY);
                                allySprite.setRotation(angle);
                            }
                        }
                    }
                    
                    for (let i = allyCount; i < allySprites.length; i++) {
                        if (allySprites[i]) {
                            allySprites[i].destroy();
                        }
                    }
                    allySprites.length = allyCount;
                }
            });
            
            for (let sessionId in otherPlayers) {
                if (!state.players[sessionId]) {
                    console.log("‚ûñ Removing disconnected player:", sessionId);
                    if (otherPlayers[sessionId]) {
                        otherPlayers[sessionId].destroy();
                    }
                    delete otherPlayers[sessionId];
                    
                    if (otherPlayerAllies[sessionId]) {
                        otherPlayerAllies[sessionId].forEach(ally => {
                            if (ally) ally.destroy();
                        });
                        delete otherPlayerAllies[sessionId];
                    }
                }
            }
            
            state.mobs.forEach((serverMob, mobId) => {
                if (!serverMobs[mobId]) {
                    const mobSprite = gameScene.physics.add.sprite(
                        serverMob.x,
                        serverMob.y,
                        'mob'
                    );
                    mobSprite.setData('hp', serverMob.hp);
                    mobSprite.setData('maxHp', serverMob.maxHp);
                    mobSprite.setData('team', 'mob');
                    mobSprite.setData('isMob', true);
                    serverMobs[mobId] = mobSprite;
                    mobs.add(mobSprite);
                } else {
                    const mobSprite = serverMobs[mobId];
                    if (mobSprite && mobSprite.active) {
                        const newX = Phaser.Math.Linear(mobSprite.x, serverMob.x, 0.5);
                        const newY = Phaser.Math.Linear(mobSprite.y, serverMob.y, 0.5);
                        mobSprite.setPosition(newX, newY);
                        mobSprite.setData('hp', serverMob.hp);
                    }
                }
            });
            
            for (let mobId in serverMobs) {
                if (!state.mobs[mobId]) {
                    if (serverMobs[mobId]) {
                        serverMobs[mobId].destroy();
                    }
                    delete serverMobs[mobId];
                }
            }
        });
        
        room.onMessage("damage", (message) => {
            console.log("üí• Damage event:", message);
        });
        
        room.onMessage("mob_killed", (message) => {
            console.log("üëπ Mob killed by:", message.killerId);
            
            const mobSprite = serverMobs[message.mobId];
            if (mobSprite && mobSprite.active) {
                for (let i = 0; i < 8; i++) {
                    const particle = gameScene.add.circle(
                        mobSprite.x, mobSprite.y, 
                        3 + Math.random() * 3, 
                        0xff4444
                    );
                    const angle = (Math.PI * 2 * i) / 8;
                    gameScene.tweens.add({
                        targets: particle,
                        x: mobSprite.x + Math.cos(angle) * 40,
                        y: mobSprite.y + Math.sin(angle) * 40,
                        alpha: 0,
                        duration: 400,
                        onComplete: () => particle.destroy()
                    });
                }
            }
            
            if (message.killerId === myPlayerId) {
                kills++;
                killText.setText(`${GameConfig.text.kills}: ${kills}`);
                
                gainXP(10);
                
                if (kills >= nextAllyAt) {
                    spawnAlly(gameScene);
                    nextAllyAt += 3;
                }
            }
        });
        
        room.onMessage("player_killed", (message) => {
            console.log("üíÄ Player killed:", message);
            
            if (message.playerId === myPlayerId) {
                showDeathScreen(gameScene);
            }
        });
        
        room.onMessage("player_respawned", (message) => {
            console.log("üîÑ Player respawned:", message.playerId);
            
            if (message.playerId === myPlayerId) {
                if (gameScene.deathOverlay) gameScene.deathOverlay.setVisible(false);
                if (gameScene.deathText) gameScene.deathText.setVisible(false);
                if (gameScene.retryButton) gameScene.retryButton.setVisible(false);
                if (gameScene.retryBg) gameScene.retryBg.setVisible(false);
                if (gameScene.deathStatsText) {
                    gameScene.deathStatsText.destroy();
                    gameScene.deathStatsText = null;
                }
                
                player.setVisible(true);
                player.body.enable = true;
                player.setData('hp', 100);
                isPlayerDead = false;
            }
        });
        
        room.onMessage("ally_killed", (message) => {
            console.log("‚öîÔ∏è Ally killed:", message);
            
            if (message.ownerId === myPlayerId) {
                if (message.allyIndex < allies.children.entries.length) {
                    const ally = allies.children.entries[message.allyIndex];
                    if (ally && ally.active) {
                        for (let i = 0; i < 5; i++) {
                            const particle = gameScene.add.circle(
                                ally.x, ally.y,
                                2 + Math.random() * 2,
                                0xff4444
                            );
                            const angle = (Math.PI * 2 * i) / 5;
                            gameScene.tweens.add({
                                targets: particle,
                                x: ally.x + Math.cos(angle) * 30,
                                y: ally.y + Math.sin(angle) * 30,
                                alpha: 0,
                                duration: 300,
                                onComplete: () => particle.destroy()
                            });
                        }
                        
                        ally.destroy();
                    }
                    
                    armyText.setText(`${GameConfig.text.army}: ${allies.children.entries.length + 1}`);
                }
            } else {
                if (otherPlayerAllies[message.ownerId] && otherPlayerAllies[message.ownerId][message.allyIndex]) {
                    const ally = otherPlayerAllies[message.ownerId][message.allyIndex];
                    if (ally && ally.active) {
                        ally.destroy();
                    }
                }
            }
        });
        
        room.onLeave((code) => {
            console.log("‚ö†Ô∏è Left room with code:", code);
            updateConnectionStatus('disconnected', GameConfig.text.disconnected);
        });
        
        room.onError((code, message) => {
            console.error("‚ùå Room error:", code, message);
            updateConnectionStatus('disconnected', `${GameConfig.text.disconnected}: ${message}`);
        });
        
    } catch (error) {
        console.error("‚ùå Failed to connect:", error);
        updateConnectionStatus('disconnected', GameConfig.text.disconnected);
    }
}

function updateConnectionStatus(status, text) {
    const statusEl = document.getElementById('connection-status');
    if (statusEl) {
        statusEl.innerHTML = `<span class="${status}">${text}</span>`;
    }
}

        function preload() {}

        function create() {
            gameScene = this;
            
            this.physics.world.setBounds(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
            
            this.cameras.main.setBounds(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
            this.cameras.main.setZoom(0.7);
            
            createEmojiTexture(this, 'player', GameConfig.emojis.player, 64);
            createEmojiTexture(this, 'knight', GameConfig.emojis.knight, 56);
            createEmojiTexture(this, 'archer', GameConfig.emojis.archer, 52);
            createEmojiTexture(this, 'mob', GameConfig.emojis.mob, 48);
            createEmojiTexture(this, 'boss', GameConfig.emojis.boss, 80);
            createEmojiTexture(this, 'powerup-speed', GameConfig.emojis.powerupSpeed, 40);
            createEmojiTexture(this, 'powerup-damage', GameConfig.emojis.powerupDamage, 40);
            createEmojiTexture(this, 'powerup-heal', GameConfig.emojis.powerupHeal, 40);
            
            const swordGfx = this.add.graphics();
            swordGfx.fillStyle(0xffff00, 1);
            swordGfx.fillRect(0, 0, 4, 12);
            swordGfx.fillStyle(0xffaa00, 1);
            swordGfx.fillTriangle(2, 0, 0, 3, 4, 3);
            swordGfx.generateTexture('sword', 4, 12);
            swordGfx.destroy();
            
            const arrowGfx = this.add.graphics();
            arrowGfx.fillStyle(0x885533, 1);
            arrowGfx.fillRect(0, 0, 2, 10);
            arrowGfx.fillStyle(0xcccccc, 1);
            arrowGfx.fillTriangle(1, 0, 0, 3, 2, 3);
            arrowGfx.generateTexture('arrow', 2, 10);
            arrowGfx.destroy();
            
            const bloodGfx = this.add.graphics();
            bloodGfx.fillStyle(0xff0000, 1);
            bloodGfx.fillCircle(3, 3, 3);
            bloodGfx.generateTexture('blood', 6, 6);
            bloodGfx.destroy();
            
            player = this.physics.add.sprite(WORLD_WIDTH / 2, WORLD_HEIGHT / 2, 'player');
            player.setData('hp', heroStats.hp);
            player.setData('maxHp', heroStats.maxHp);
            player.setData('damage', heroStats.damage);
            player.setData('attackRange', heroStats.range);
            player.setData('attackSpeed', 500);
            player.setData('lastAttack', 0);
            player.setData('isPlayer', true);
            player.setData('team', 'blue');
            player.setData('heroClass', selectedClass);
            
            this.cameras.main.startFollow(player, true, 0.1, 0.1);
            
            const classColor = CLASS_CONFIGS[selectedClass].color;
            const glow = this.add.circle(player.x, player.y, 35, classColor, 0.2);
            glow.setBlendMode(Phaser.BlendModes.ADD);
            this.tweens.add({
                targets: glow,
                alpha: { from: 0.2, to: 0.4 },
                scale: { from: 1, to: 1.2 },
                duration: 1000,
                yoyo: true,
                repeat: -1
            });
            
            this.events.on('update', () => {
                if (player && player.active) {
                    glow.setPosition(player.x, player.y);
                }
            });
            
            allies = this.physics.add.group();
            enemyAllies = this.physics.add.group();
            mobs = this.physics.add.group();
            powerups = this.physics.add.group();
            bosses = this.physics.add.group();
            
            pointer = this.input.activePointer;
            
            this.input.keyboard.on('keydown-Q', () => useDashAbility(this));
            this.input.keyboard.on('keydown-E', () => useAOEAbility(this));
            
            killText = this.add.text(20, 20, `${GameConfig.text.kills}: 0`, {
                fontSize: '32px',
                color: '#ffffff',
                fontStyle: 'bold',
                stroke: '#000000',
                strokeThickness: 5
            }).setScrollFactor(0, 0).setDepth(2000).setOrigin(0, 0);
            
            armyText = this.add.text(20, 65, `${GameConfig.text.army}: 1`, {
                fontSize: '28px',
                color: '#ffaa00',
                fontStyle: 'bold',
                stroke: '#000000',
                strokeThickness: 4
            }).setScrollFactor(0, 0).setDepth(2000).setOrigin(0, 0);
            
            playerCountText = this.add.text(20, 105, `${GameConfig.text.players}: 1`, {
                fontSize: '24px',
                color: '#00ffff',
                fontStyle: 'bold',
                stroke: '#000000',
                strokeThickness: 4
            }).setScrollFactor(0, 0).setDepth(2000).setOrigin(0, 0);
            
            this.add.text(600, 15, GameConfig.text.legend, {
                fontSize: '24px',
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5, 0).setScrollFactor(0).setDepth(2000);
            
            this.add.text(600, 755, GameConfig.text.controls, {
                fontSize: '18px',
                color: '#aaaaaa',
                stroke: '#000000',
                strokeThickness: 2
            }).setOrigin(0.5).setScrollFactor(0);
            
            const restartBg = this.add.rectangle(1150, 30, 90, 40, 0x444444)
                .setScrollFactor(0)
                .setDepth(500)
                .setInteractive({ useHandCursor: true });
            
            const restartText = this.add.text(1150, 30, GameConfig.text.restart, {
                fontSize: '18px',
                color: '#ffffff',
                fontStyle: 'bold'
            }).setOrigin(0.5).setScrollFactor(0).setDepth(501);
            
            restartBg.on('pointerover', () => {
                restartBg.setFillStyle(0x666666);
            });
            restartBg.on('pointerout', () => {
                restartBg.setFillStyle(0x444444);
            });
            restartBg.on('pointerdown', () => {
                location.reload();
            });
            
            deathOverlay = this.add.rectangle(600, 400, 10000, 10000, 0x000000, 0.8)
                .setScrollFactor(0)
                .setDepth(1000)
                .setVisible(false);
            
            deathText = this.add.text(600, 300, GameConfig.text.youDied, {
                fontSize: '72px',
                color: '#ff0000',
                fontStyle: 'bold',
                stroke: '#000000',
                strokeThickness: 8
            }).setOrigin(0.5).setScrollFactor(0).setDepth(1001).setVisible(false);
            
            const retryBg = this.add.rectangle(600, 420, 200, 60, 0x444444)
                .setScrollFactor(0)
                .setDepth(1001)
                .setVisible(false)
                .setInteractive({ useHandCursor: true });
            
            retryButton = this.add.text(600, 420, GameConfig.text.retry, {
                fontSize: '32px',
                color: '#ffffff',
                fontStyle: 'bold'
            }).setOrigin(0.5).setScrollFactor(0).setDepth(1002).setVisible(false);
            
            retryBg.on('pointerover', () => {
                retryBg.setFillStyle(0x666666);
            });
            retryBg.on('pointerout', () => {
                retryBg.setFillStyle(0x444444);
            });
            retryBg.on('pointerdown', () => {
                location.reload();
            });
            
            this.deathOverlay = deathOverlay;
            this.deathText = deathText;
            this.retryButton = retryButton;
            this.retryBg = retryBg;
            
            this.time.addEvent({
                delay: 10000,
                callback: () => {
                    spawnPowerup(this);
                },
                loop: true
            });
            
            for (let i = 0; i < 5; i++) {
                spawnPowerup(this);
            }
            
            this.time.addEvent({
                delay: 20000,
                callback: () => {
                    spawnBoss(this);
                },
                loop: true
            });
            
            spawnBoss(this);
            
            console.log("‚úÖ Game scene created, connecting to multiplayer...");
            connectToMultiplayer();
        }

        function createEmojiTexture(scene, key, emoji, size) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            ctx.font = `${size * 0.8}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, size / 2, size / 2);
            
            scene.textures.addCanvas(key, canvas);
        }

        function update(time, delta) {
            if (isPlayerDead) return;
            
            if (player && player.active) {
                const distance = Phaser.Math.Distance.Between(
                    player.x, player.y,
                    pointer.worldX, pointer.worldY
                );
                
                const speed = heroStats.speed;
                
                if (distance > 20) {
                    const angle = Phaser.Math.Angle.Between(
                        player.x, player.y,
                        pointer.worldX, pointer.worldY
                    );
                    
                    player.rotation = angle + Math.PI / 2;
                    
                    player.setVelocity(
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed
                    );
                    
                    player.setData('facingAngle', angle);
                    
                    const now = Date.now();
                    if (room && room.sessionId && (now - lastInputSent) >= INPUT_SEND_INTERVAL) {
                        lastInputSent = now;
                        
                        room.send("move", {
                            x: player.x,
                            y: player.y,
                            angle: angle
                        });
                    }
                } else {
                    player.setVelocity(0, 0);
                }
                
                const now = Date.now();
                if (room && room.sessionId && (now - lastInputSent) >= INPUT_SEND_INTERVAL) {
                    lastInputSent = now;
                    
                    const allyPositions = allies.children.entries
                        .filter(ally => ally && ally.active)
                        .slice(0, 100)
                        .map(ally => ({
                            x: ally.x,
                            y: ally.y,
                            angle: ally.rotation,
                            isArcher: ally.getData('isArcher') || false
                        }));
                    
                    room.send("update_allies", {
                        allies: allyPositions
                    });
                }
                
                player.x = Phaser.Math.Clamp(player.x, 30, WORLD_WIDTH - 30);
                player.y = Phaser.Math.Clamp(player.y, 30, WORLD_HEIGHT - 30);
                
                autoAttack(game.scene.scenes[0], player, time);
            }
            
            const armySize = allies.children.entries.length + 1;
            const targetZoom = Math.max(0.4, 0.7 - (armySize * 0.01));
            const currentZoom = game.scene.scenes[0].cameras.main.zoom;
            const newZoom = currentZoom + (targetZoom - currentZoom) * 0.05;
            game.scene.scenes[0].cameras.main.setZoom(newZoom);
            
            bosses.children.entries.forEach(boss => {
                if (!boss || !boss.active || !player || !player.active) return;
                
                const dist = Phaser.Math.Distance.Between(boss.x, boss.y, player.x, player.y);
                
                if (dist < 400) {
                    const angle = Phaser.Math.Angle.Between(boss.x, boss.y, player.x, player.y);
                    boss.setVelocity(Math.cos(angle) * 80, Math.sin(angle) * 80);
                    autoAttack(game.scene.scenes[0], boss, time);
                } else {
                    if (!boss.getData('targetX') || Math.random() < 0.02) {
                        boss.setData('targetX', Math.random() * WORLD_WIDTH);
                        boss.setData('targetY', Math.random() * WORLD_HEIGHT);
                    }
                    const angle = Phaser.Math.Angle.Between(
                        boss.x, boss.y,
                        boss.getData('targetX'),
                        boss.getData('targetY')
                    );
                    boss.setVelocity(Math.cos(angle) * 50, Math.sin(angle) * 50);
                }
            });
            
            powerups.children.entries.forEach(powerup => {
                if (!powerup || !powerup.active || !player || !player.active) return;
                
                const dist = Phaser.Math.Distance.Between(player.x, player.y, powerup.x, powerup.y);
                if (dist < 40) {
                    collectPowerup(game.scene.scenes[0], powerup);
                }
            });
            
            renderHealthBars(game.scene.scenes[0]);
            
            const knights = [];
            const archers = [];
            
            allies.children.entries.forEach(ally => {
                if (!ally || !ally.active) return;
                if (ally.getData('isArcher')) {
                    archers.push(ally);
                } else {
                    knights.push(ally);
                }
            });
            
            const playerAngle = player.getData('facingAngle') || 0;
            
            function getCenterOutPosition(index, maxPerRow) {
                const row = Math.floor(index / maxPerRow);
                const posInRow = index % maxPerRow;
                
                let colOffset;
                if (posInRow === 0 && maxPerRow === 1) {
                    colOffset = 0;
                } else {
                    const side = posInRow % 2 === 0 ? 1 : -1;
                    const distance = Math.ceil(posInRow / 2);
                    colOffset = side * distance;
                }
                
                return { row, col: colOffset };
            }
            
            knights.forEach((knight, index) => {
                const pos = getCenterOutPosition(index, 10);
                
                const horizontalSpacing = 45;
                const forwardSpacing = 50;
                
                const forwardX = Math.cos(playerAngle);
                const forwardY = Math.sin(playerAngle);
                const rightX = -Math.sin(playerAngle);
                const rightY = Math.cos(playerAngle);
                
                const targetX = player.x + (forwardX * forwardSpacing * (pos.row + 1)) + (rightX * horizontalSpacing * pos.col);
                const targetY = player.y + (forwardY * forwardSpacing * (pos.row + 1)) + (rightY * horizontalSpacing * pos.col);
                
                const distance = Phaser.Math.Distance.Between(
                    knight.x, knight.y,
                    targetX, targetY
                );
                
                if (distance > 15) {
                    const angle = Phaser.Math.Angle.Between(
                        knight.x, knight.y,
                        targetX, targetY
                    );
                    
                    const speed = 220;
                    knight.setVelocity(
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed
                    );
                    
                    knight.rotation = playerAngle + Math.PI / 2;
                } else {
                    knight.setVelocity(
                        knight.body.velocity.x * 0.88,
                        knight.body.velocity.y * 0.88
                    );
                }
                
                knight.x = Phaser.Math.Clamp(knight.x, 30, WORLD_WIDTH - 30);
                knight.y = Phaser.Math.Clamp(knight.y, 30, WORLD_HEIGHT - 30);
                
                autoAttack(game.scene.scenes[0], knight, time);
            });
            
            archers.forEach((archer, index) => {
                const pos = getCenterOutPosition(index, 10);
                
                const horizontalSpacing = 45;
                const backwardSpacing = 50;
                
                const backwardX = -Math.cos(playerAngle);
                const backwardY = -Math.sin(playerAngle);
                const rightX = -Math.sin(playerAngle);
                const rightY = Math.cos(playerAngle);
                
                const targetX = player.x + (backwardX * backwardSpacing * (pos.row + 1)) + (rightX * horizontalSpacing * pos.col);
                const targetY = player.y + (backwardY * backwardSpacing * (pos.row + 1)) + (rightY * horizontalSpacing * pos.col);
                
                const distance = Phaser.Math.Distance.Between(
                    archer.x, archer.y,
                    targetX, targetY
                );
                
                if (distance > 15) {
                    const angle = Phaser.Math.Angle.Between(
                        archer.x, archer.y,
                        targetX, targetY
                    );
                    
                    const speed = 210;
                    archer.setVelocity(
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed
                    );
                    
                    archer.rotation = playerAngle + Math.PI / 2;
                } else {
                    archer.setVelocity(
                        archer.body.velocity.x * 0.88,
                        archer.body.velocity.y * 0.88
                    );
                }
                
                archer.x = Phaser.Math.Clamp(archer.x, 30, WORLD_WIDTH - 30);
                archer.y = Phaser.Math.Clamp(archer.y, 30, WORLD_HEIGHT - 30);
                
                autoAttack(game.scene.scenes[0], archer, time);
            });
            
            mobs.children.entries.forEach(mob => {
                if (!mob || !mob.active) return;
                
                if (!mob.getData('targetX')) {
                    setRandomTarget(mob);
                }
                
                const distance = Phaser.Math.Distance.Between(
                    mob.x, mob.y,
                    mob.getData('targetX'),
                    mob.getData('targetY')
                );
                
                if (distance < 20 || time - mob.getData('lastMove') > 3000) {
                    setRandomTarget(mob);
                    mob.setData('lastMove', time);
                }
                
                const angle = Phaser.Math.Angle.Between(
                    mob.x, mob.y,
                    mob.getData('targetX'),
                    mob.getData('targetY')
                );
                
                const speed = 55;
                mob.setVelocity(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed
                );
                
                mob.x = Phaser.Math.Clamp(mob.x, 30, WORLD_WIDTH - 30);
                mob.y = Phaser.Math.Clamp(mob.y, 30, WORLD_HEIGHT - 30);
            });
        }

        function showDeathScreen(scene) {
            isPlayerDead = true;
            
            scene.deathOverlay.setVisible(true);
            scene.deathText.setVisible(true);
            scene.retryButton.setVisible(true);
            scene.retryBg.setVisible(true);
            
            if (scene.deathStatsText) {
                scene.deathStatsText.destroy();
            }
            scene.deathStatsText = scene.add.text(600, 360, `${GameConfig.text.kills}: ${kills}  ‚Ä¢  ${GameConfig.text.army} Size: ${allies.children.entries.length + 1}`, {
                fontSize: '24px',
                color: '#ffaa00',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5).setScrollFactor(0).setDepth(1001);
        }

        function renderHealthBars(scene) {
            if (scene.healthBarGraphics) {
                scene.healthBarGraphics.clear();
            } else {
                scene.healthBarGraphics = scene.add.graphics();
                scene.healthBarGraphics.setDepth(999);
            }
            
            const graphics = scene.healthBarGraphics;
            
            function drawHealthBar(unit, yOffset = -35) {
                if (!unit || !unit.active) return;
                
                const hp = unit.getData('hp');
                const maxHp = unit.getData('maxHp');
                if (!hp || !maxHp) return;
                
                const barWidth = 40;
                const barHeight = 5;
                const x = unit.x - barWidth / 2;
                const y = unit.y + yOffset;
                
                graphics.fillStyle(0x000000, 0.5);
                graphics.fillRect(x - 1, y - 1, barWidth + 2, barHeight + 2);
                graphics.fillStyle(0xff0000, 1);
                graphics.fillRect(x, y, barWidth, barHeight);
                
                const healthPercent = Math.max(0, hp / maxHp);
                const team = unit.getData('team');
                const healthColor = team === 'red' ? 0xff6666 : 0x00ff00;
                graphics.fillStyle(healthColor, 1);
                graphics.fillRect(x, y, barWidth * healthPercent, barHeight);
            }
            
            if (player && player.active) {
                drawHealthBar(player, -40);
            }
            
            allies.children.entries.forEach(ally => {
                drawHealthBar(ally, -30);
            });
            
            if (enemyPlayer && enemyPlayer.active) {
                drawHealthBar(enemyPlayer, -40);
            }
            
            enemyAllies.children.entries.forEach(ally => {
                drawHealthBar(ally, -30);
            });
            
            for (let sessionId in otherPlayers) {
                const otherPlayer = otherPlayers[sessionId];
                if (otherPlayer && otherPlayer.active) {
                    drawHealthBar(otherPlayer, -40);
                }
            }
            
            for (let sessionId in otherPlayerAllies) {
                const allies = otherPlayerAllies[sessionId];
                allies.forEach(ally => {
                    if (ally && ally.active) {
                        drawHealthBar(ally, -30);
                    }
                });
            }
            
            mobs.children.entries.forEach(mob => {
                drawHealthBar(mob, -30);
            });
            
            bosses.children.entries.forEach(boss => {
                drawHealthBar(boss, -45);
            });
        }

        function updateEnemyFormation(time) {
            if (!enemyPlayer || !enemyPlayer.active) return;
            
            const enemyKnights = [];
            const enemyArchers = [];
            
            enemyAllies.children.entries.forEach(ally => {
                if (!ally || !ally.active) return;
                if (ally.getData('isArcher')) {
                    enemyArchers.push(ally);
                } else {
                    enemyKnights.push(ally);
                }
            });
            
            const enemyAngle = enemyPlayer.getData('facingAngle') || 0;
            
            function getCenterOutPosition(index, maxPerRow) {
                const row = Math.floor(index / maxPerRow);
                const posInRow = index % maxPerRow;
                let colOffset;
                if (posInRow === 0 && maxPerRow === 1) {
                    colOffset = 0;
                } else {
                    const side = posInRow % 2 === 0 ? 1 : -1;
                    const distance = Math.ceil(posInRow / 2);
                    colOffset = side * distance;
                }
                return { row, col: colOffset };
            }
            
            enemyKnights.forEach((knight, index) => {
                const pos = getCenterOutPosition(index, 10);
                const horizontalSpacing = 45;
                const forwardSpacing = 50;
                
                const forwardX = Math.cos(enemyAngle);
                const forwardY = Math.sin(enemyAngle);
                const rightX = -Math.sin(enemyAngle);
                const rightY = Math.cos(enemyAngle);
                
                const targetX = enemyPlayer.x + (forwardX * forwardSpacing * (pos.row + 1)) + (rightX * horizontalSpacing * pos.col);
                const targetY = enemyPlayer.y + (forwardY * forwardSpacing * (pos.row + 1)) + (rightY * horizontalSpacing * pos.col);
                
                const distance = Phaser.Math.Distance.Between(knight.x, knight.y, targetX, targetY);
                
                if (distance > 15) {
                    const angle = Phaser.Math.Angle.Between(knight.x, knight.y, targetX, targetY);
                    knight.setVelocity(Math.cos(angle) * 220, Math.sin(angle) * 220);
                    knight.rotation = enemyAngle + Math.PI / 2;
                } else {
                    knight.setVelocity(knight.body.velocity.x * 0.88, knight.body.velocity.y * 0.88);
                }
                
                knight.x = Phaser.Math.Clamp(knight.x, 30, WORLD_WIDTH - 30);
                knight.y = Phaser.Math.Clamp(knight.y, 30, WORLD_HEIGHT - 30);
                
                autoAttack(game.scene.scenes[0], knight, time);
            });
            
            enemyArchers.forEach((archer, index) => {
                const pos = getCenterOutPosition(index, 10);
                const horizontalSpacing = 45;
                const backwardSpacing = 50;
                
                const backwardX = -Math.cos(enemyAngle);
                const backwardY = -Math.sin(enemyAngle);
                const rightX = -Math.sin(enemyAngle);
                const rightY = Math.cos(enemyAngle);
                
                const targetX = enemyPlayer.x + (backwardX * backwardSpacing * (pos.row + 1)) + (rightX * horizontalSpacing * pos.col);
                const targetY = enemyPlayer.y + (backwardY * backwardSpacing * (pos.row + 1)) + (rightY * horizontalSpacing * pos.col);
                
                const distance = Phaser.Math.Distance.Between(archer.x, archer.y, targetX, targetY);
                
                if (distance > 15) {
                    const angle = Phaser.Math.Angle.Between(archer.x, archer.y, targetX, targetY);
                    archer.setVelocity(Math.cos(angle) * 210, Math.sin(angle) * 210);
                    archer.rotation = enemyAngle + Math.PI / 2;
                } else {
                    archer.setVelocity(archer.body.velocity.x * 0.88, archer.body.velocity.y * 0.88);
                }
                
                archer.x = Phaser.Math.Clamp(archer.x, 30, WORLD_WIDTH - 30);
                archer.y = Phaser.Math.Clamp(archer.y, 30, WORLD_HEIGHT - 30);
                
                autoAttack(game.scene.scenes[0], archer, time);
            });
        }

        function setRandomTarget(mob) {
            mob.setData('targetX', Phaser.Math.Between(100, WORLD_WIDTH - 100));
            mob.setData('targetY', Phaser.Math.Between(100, WORLD_HEIGHT - 100));
        }

        function spawnEnemyAlly(scene, type, index) {
            const isArcher = type === 'archer';
            const texture = isArcher ? 'archer' : 'knight';
            
            const ally = enemyAllies.create(
                enemyPlayer.x + Math.random() * 200 - 100,
                enemyPlayer.y + Math.random() * 200 - 100,
                texture
            );
            
            ally.setTint(0xff8888);
            ally.setData('team', 'red');
            
            if (isArcher) {
                ally.setData('isArcher', true);
                ally.setData('hp', 5);
                ally.setData('maxHp', 5);
                ally.setData('damage', 2.5);
                ally.setData('attackRange', 160);
                ally.setData('attackSpeed', 850);
            } else {
                ally.setData('hp', 10);
                ally.setData('maxHp', 10);
                ally.setData('damage', 5);
                ally.setData('attackRange', 75);
                ally.setData('attackSpeed', 550);
            }
            
            ally.setData('lastAttack', 0);
        }

        function autoAttack(scene, attacker, time) {
            if (!attacker || !attacker.active) return;
            
            const lastAttack = attacker.getData('lastAttack') || 0;
            const attackSpeed = attacker.getData('attackSpeed') || 500;
            
            if (time - lastAttack < attackSpeed) return;
            
            const attackRange = attacker.getData('attackRange') || 80;
            const damage = attacker.getData('damage') || 10;
            const isArcher = attacker.getData('isArcher') || false;
            const attackerTeam = attacker.getData('team');
            
            let nearest = null;
            let minDist = attackRange;
            let targetType = null;
            
            if (attackerTeam === 'blue') {
                for (let sessionId in otherPlayers) {
                    const enemyHero = otherPlayers[sessionId];
                    if (!enemyHero || !enemyHero.active) continue;
                    
                    const dist = Phaser.Math.Distance.Between(
                        attacker.x, attacker.y,
                        enemyHero.x, enemyHero.y
                    );
                    
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = enemyHero;
                        targetType = 'player';
                    }
                }
                
                for (let sessionId in otherPlayerAllies) {
                    const enemyAllies = otherPlayerAllies[sessionId];
                    enemyAllies.forEach(enemy => {
                        if (!enemy || !enemy.active) return;
                        
                        const dist = Phaser.Math.Distance.Between(
                            attacker.x, attacker.y,
                            enemy.x, enemy.y
                        );
                        
                        if (dist < minDist) {
                            minDist = dist;
                            nearest = enemy;
                            targetType = 'unit';
                        }
                    });
                }
            }
            
            mobs.children.entries.forEach(mob => {
                if (!mob || !mob.active) return;
                
                const dist = Phaser.Math.Distance.Between(
                    attacker.x, attacker.y,
                    mob.x, mob.y
                );
                
                if (dist < minDist) {
                    minDist = dist;
                    nearest = mob;
                    targetType = 'mob';
                }
            });
            
            bosses.children.entries.forEach(boss => {
                if (!boss || !boss.active) return;
                
                const dist = Phaser.Math.Distance.Between(
                    attacker.x, attacker.y,
                    boss.x, boss.y
                );
                
                if (dist < minDist) {
                    minDist = dist;
                    nearest = boss;
                    targetType = 'boss';
                }
            });
            
            if (nearest) {
                attacker.setData('lastAttack', time);
                
                if (isArcher) {
                    const arrow = scene.add.sprite(attacker.x, attacker.y, 'arrow');
                    const angle = Phaser.Math.Angle.Between(
                        attacker.x, attacker.y,
                        nearest.x, nearest.y
                    );
                    arrow.setRotation(angle);
                    arrow.setScale(2);
                    
                    scene.tweens.add({
                        targets: arrow,
                        x: nearest.x,
                        y: nearest.y,
                        duration: 120,
                        onComplete: () => {
                            arrow.destroy();
                            if (nearest && nearest.active) {
                                if (targetType === 'mob') {
                                    damageMob(scene, nearest, damage);
                                } else if (targetType === 'boss') {
                                    damageBoss(scene, nearest, damage);
                                } else {
                                    damageUnit(scene, nearest, damage, targetType);
                                }
                            }
                        }
                    });
                } else {
                    const slash = scene.add.sprite(attacker.x, attacker.y, 'sword');
                    slash.setAlpha(0.9);
                    slash.setScale(2);
                    const angle = Phaser.Math.Angle.Between(
                        attacker.x, attacker.y,
                        nearest.x, nearest.y
                    );
                    slash.setRotation(angle);
                    
                    scene.tweens.add({
                        targets: slash,
                        x: nearest.x,
                        y: nearest.y,
                        alpha: 0,
                        rotation: angle + Math.PI * 0.5,
                        duration: 120,
                        onComplete: () => slash.destroy()
                    });
                    
                    if (targetType === 'mob') {
                        damageMob(scene, nearest, damage);
                    } else if (targetType === 'boss') {
                        damageBoss(scene, nearest, damage);
                    } else {
                        damageUnit(scene, nearest, damage, targetType);
                    }
                }
            }
        }

        function damageUnit(scene, unit, damage, unitType) {
            if (!unit || !unit.active) return;
            
            if (unitType === 'player' && unit.getData('isOtherPlayer')) {
                let targetPlayerId = null;
                for (let sessionId in otherPlayers) {
                    if (otherPlayers[sessionId] === unit) {
                        targetPlayerId = sessionId;
                        break;
                    }
                }
                
                if (targetPlayerId && room) {
                    room.send("attack", {
                        targetId: targetPlayerId,
                        targetType: 'player'
                    });
                }
            }
            
            if (unitType === 'unit' && unit.getData('team') === 'red') {
                let targetPlayerId = null;
                let allyIndex = -1;
                
                for (let sessionId in otherPlayerAllies) {
                    const allies = otherPlayerAllies[sessionId];
                    const index = allies.indexOf(unit);
                    if (index !== -1) {
                        targetPlayerId = sessionId;
                        allyIndex = index;
                        break;
                    }
                }
                
                if (targetPlayerId && allyIndex !== -1 && room) {
                    room.send("attack", {
                        targetId: targetPlayerId,
                        targetType: 'ally',
                        allyIndex: allyIndex
                    });
                }
            }
            
            const hp = unit.getData('hp') - damage;
            unit.setData('hp', hp);
            
            unit.setTint(0xffffff);
            scene.time.delayedCall(80, () => {
                if (unit && unit.active) {
                    const team = unit.getData('team');
                    if (team === 'red') {
                        unit.setTint(unitType === 'player' ? 0xff4444 : 0xff8888);
                    } else {
                        unit.clearTint();
                    }
                }
            });
            
            for (let i = 0; i < 3; i++) {
                const blood = scene.add.sprite(unit.x, unit.y, 'blood');
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 15 + 10;
                
                scene.tweens.add({
                    targets: blood,
                    x: unit.x + Math.cos(angle) * dist,
                    y: unit.y + Math.sin(angle) * dist,
                    alpha: 0,
                    scale: { from: 1, to: 0.3 },
                    duration: 350,
                    onComplete: () => blood.destroy()
                });
            }
            
            if (hp <= 0) {
                for (let i = 0; i < 5; i++) {
                    const particle = scene.add.circle(
                        unit.x, unit.y,
                        2 + Math.random() * 2,
                        0xff4444
                    );
                    const angle = (Math.PI * 2 * i) / 5;
                    scene.tweens.add({
                        targets: particle,
                        x: unit.x + Math.cos(angle) * 30,
                        y: unit.y + Math.sin(angle) * 30,
                        alpha: 0,
                        duration: 300,
                        onComplete: () => particle.destroy()
                    });
                }
                
                if (unitType === 'player' && unit === player) {
                    showDeathScreen(scene);
                    unit.setVisible(false);
                    unit.body.enable = false;
                } else {
                    unit.destroy();
                }
                
                if (unit.getData('team') === 'blue' && unit !== player) {
                    armyText.setText(`${GameConfig.text.army}: ${allies.children.entries.length + 1}`);
                }
            }
        }

        function damageMob(scene, mob, damage) {
            if (!mob || !mob.active) return;
            
            let mobId = null;
            for (let id in serverMobs) {
                if (serverMobs[id] === mob) {
                    mobId = id;
                    break;
                }
            }
            
            if (!mobId || !room) return;
            
            room.send("attack", {
                targetId: mobId,
                targetType: 'mob'
            });
            
            mob.setTint(0xffffff);
            scene.time.delayedCall(80, () => {
                if (mob && mob.active) mob.clearTint();
            });
            
            for (let i = 0; i < 6; i++) {
                const blood = scene.add.sprite(mob.x, mob.y, 'blood');
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 25 + 15;
                
                scene.tweens.add({
                    targets: blood,
                    x: mob.x + Math.cos(angle) * dist,
                    y: mob.y + Math.sin(angle) * dist,
                    alpha: 0,
                    scale: { from: 1, to: 0.3 },
                    duration: 450,
                    onComplete: () => blood.destroy()
                });
            }
        }

        function useDashAbility(scene) {
            if (!player || !player.active || isPlayerDead) return;
            
            const now = Date.now();
            const dashCooldown = abilities.dash.cooldown;
            const timeSince = now - abilities.dash.lastUsed;
            
            if (timeSince < dashCooldown) {
                return;
            }
            
            abilities.dash.lastUsed = now;
            
            const angle = player.getData('facingAngle') || 0;
            const dashDistance = 200;
            const dashX = player.x + Math.cos(angle) * dashDistance;
            const dashY = player.y + Math.sin(angle) * dashDistance;
            
            const targetX = Phaser.Math.Clamp(dashX, 30, WORLD_WIDTH - 30);
            const targetY = Phaser.Math.Clamp(dashY, 30, WORLD_HEIGHT - 30);
            
            scene.tweens.add({
                targets: player,
                x: targetX,
                y: targetY,
                duration: 150,
                ease: 'Power2'
            });
            
            const dashTrail = scene.add.circle(player.x, player.y, 40, CLASS_CONFIGS[selectedClass].color, 0.5);
            scene.tweens.add({
                targets: dashTrail,
                alpha: 0,
                scale: 2,
                duration: 300,
                onComplete: () => dashTrail.destroy()
            });
            
            startAbilityCooldown('Q', dashCooldown);
        }
        
        function useAOEAbility(scene) {
            if (!player || !player.active || isPlayerDead) return;
            
            const now = Date.now();
            const aoeCooldown = abilities.aoe.cooldown;
            const timeSince = now - abilities.aoe.lastUsed;
            
            if (timeSince < aoeCooldown) {
                return;
            }
            
            abilities.aoe.lastUsed = now;
            
            const aoeRange = 200;
            const aoeDamage = heroStats.damage * 2;
            
            const aoeCircle = scene.add.circle(player.x, player.y, aoeRange, 0xff0000, 0.3);
            scene.tweens.add({
                targets: aoeCircle,
                alpha: 0,
                scale: 1.3,
                duration: 500,
                onComplete: () => aoeCircle.destroy()
            });
            
            mobs.children.entries.forEach(mob => {
                if (!mob || !mob.active) return;
                const dist = Phaser.Math.Distance.Between(player.x, player.y, mob.x, mob.y);
                if (dist <= aoeRange) {
                    damageMob(scene, mob, aoeDamage);
                }
            });
            
            bosses.children.entries.forEach(boss => {
                if (!boss || !boss.active) return;
                const dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
                if (dist <= aoeRange) {
                    damageBoss(scene, boss, aoeDamage);
                }
            });
            
            for (let sessionId in otherPlayers) {
                const enemy = otherPlayers[sessionId];
                if (!enemy || !enemy.active) continue;
                const dist = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
                if (dist <= aoeRange) {
                    damageUnit(scene, enemy, aoeDamage, 'player');
                }
            }
            
            for (let sessionId in otherPlayerAllies) {
                const allies = otherPlayerAllies[sessionId];
                allies.forEach(ally => {
                    if (!ally || !ally.active) return;
                    const dist = Phaser.Math.Distance.Between(player.x, player.y, ally.x, ally.y);
                    if (dist <= aoeRange) {
                        damageUnit(scene, ally, aoeDamage, 'unit');
                    }
                });
            }
            
            startAbilityCooldown('E', aoeCooldown);
        }
        
        function startAbilityCooldown(key, cooldownMs) {
            const abilities = document.querySelectorAll('.ability');
            abilities.forEach(abilityEl => {
                if (abilityEl.dataset.key === key) {
                    const cooldownDiv = abilityEl.querySelector('.ability-cooldown');
                    let remaining = Math.ceil(cooldownMs / 1000);
                    
                    cooldownDiv.textContent = remaining;
                    cooldownDiv.style.display = 'flex';
                    
                    const interval = setInterval(() => {
                        remaining--;
                        if (remaining <= 0) {
                            clearInterval(interval);
                            cooldownDiv.style.display = 'none';
                        } else {
                            cooldownDiv.textContent = remaining;
                        }
                    }, 1000);
                }
            });
        }

        function spawnAlly(scene) {
            if (!player || !player.active) return;
            
            if (allies.children.entries.length >= 100) {
                return;
            }
            
            const isArcher = Math.random() < 0.4;
            const texture = isArcher ? 'archer' : 'knight';
            
            const angle = Math.random() * Math.PI * 2;
            const dist = 60 + Math.random() * 40;
            
            const ally = allies.create(
                player.x + Math.cos(angle) * dist,
                player.y + Math.sin(angle) * dist,
                texture
            );
            
            ally.setData('team', 'blue');
            
            if (isArcher) {
                ally.setData('isArcher', true);
                ally.setData('hp', 5);
                ally.setData('maxHp', 5);
                ally.setData('damage', 2.5);
                ally.setData('attackRange', 160);
                ally.setData('attackSpeed', 850);
            } else {
                ally.setData('hp', 10);
                ally.setData('maxHp', 10);
                ally.setData('damage', 5);
                ally.setData('attackRange', 75);
                ally.setData('attackSpeed', 550);
            }
            
            ally.setData('lastAttack', 0);
            
            ally.setScale(0);
            ally.setAlpha(0);
            scene.tweens.add({
                targets: ally,
                scale: 1,
                alpha: 1,
                duration: 400,
                ease: 'Back.easeOut'
            });
            
            const flash = scene.add.circle(ally.x, ally.y, 50, 0xffaa00, 0.6);
            scene.tweens.add({
                targets: flash,
                alpha: 0,
                scale: 2,
                duration: 400,
                onComplete: () => flash.destroy()
            });
            
            armyText.setText(`${GameConfig.text.army}: ${allies.children.entries.length + 1}`);
        }
        
        function spawnPowerup(scene) {
            const types = ['speed', 'damage', 'heal'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            const powerup = powerups.create(
                Math.random() * WORLD_WIDTH,
                Math.random() * WORLD_HEIGHT,
                `powerup-${type}`
            );
            
            powerup.setData('type', type);
            
            scene.tweens.add({
                targets: powerup,
                y: powerup.y - 10,
                duration: 1000,
                yoyo: true,
                repeat: -1
            });
        }
        
        function collectPowerup(scene, powerup) {
            const type = powerup.getData('type');
            
            const text = scene.add.text(powerup.x, powerup.y - 20, '', {
                fontSize: '20px',
                color: '#ffd700',
                fontStyle: 'bold'
            }).setOrigin(0.5);
            
            if (type === 'speed') {
                text.setText(GameConfig.text.powerupSpeed);
                const old = heroStats.speed;
                heroStats.speed *= 1.5;
                scene.time.delayedCall(8000, () => { heroStats.speed = old; });
            } else if (type === 'damage') {
                text.setText(GameConfig.text.powerupDamage);
                const old = heroStats.damage;
                heroStats.damage *= 2;
                player.setData('damage', heroStats.damage);
                scene.time.delayedCall(8000, () => { 
                    heroStats.damage = old;
                    player.setData('damage', old);
                });
            } else {
                text.setText(GameConfig.text.powerupHeal);
                heroStats.hp = heroStats.maxHp;
                player.setData('hp', heroStats.hp);
            }
            
            scene.tweens.add({
                targets: text,
                y: text.y - 40,
                alpha: 0,
                duration: 1500,
                onComplete: () => text.destroy()
            });
            
            powerup.destroy();
            updateHeroHUD();
        }
        
        function spawnBoss(scene) {
            const boss = bosses.create(
                Math.random() * WORLD_WIDTH,
                Math.random() * WORLD_HEIGHT,
                'boss'
            );
            
            boss.setData('hp', 200);
            boss.setData('maxHp', 200);
            boss.setData('damage', 30);
            boss.setData('attackRange', 100);
            boss.setData('attackSpeed', 800);
            boss.setData('lastAttack', 0);
            boss.setData('team', 'boss');
            boss.setData('isBoss', true);
        }
        
        function damageBoss(scene, boss, damage) {
            if (!boss || !boss.active) return;
            
            const hp = boss.getData('hp') - damage;
            boss.setData('hp', hp);
            
            boss.setTint(0xffffff);
            scene.time.delayedCall(80, () => {
                if (boss && boss.active) boss.clearTint();
            });
            
            if (hp <= 0) {
                for (let i = 0; i < 12; i++) {
                    const particle = scene.add.circle(boss.x, boss.y, 5, 0xff0000);
                    const angle = (Math.PI * 2 * i) / 12;
                    scene.tweens.add({
                        targets: particle,
                        x: boss.x + Math.cos(angle) * 60,
                        y: boss.y + Math.sin(angle) * 60,
                        alpha: 0,
                        duration: 500,
                        onComplete: () => particle.destroy()
                    });
                }
                
                gainXP(100);
                kills += 5;
                killText.setText(`${GameConfig.text.kills}: ${kills}`);
                
                const text = scene.add.text(boss.x, boss.y, GameConfig.text.bossDefeated, {
                    fontSize: '32px',
                    color: '#ff0000',
                    fontStyle: 'bold'
                }).setOrigin(0.5);
                
                scene.tweens.add({
                    targets: text,
                    y: text.y - 80,
                    alpha: 0,
                    duration: 2000,
                    onComplete: () => text.destroy()
                });
                
                boss.destroy();
            }
        }
    </script>
</body>
</html>